<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../css/styles.css">
    <title>Doofus Developer #1 - Automating my virus scanning</title>
</head>
<body>

<br>
Scanning downloaded files is the type of task that's not a clear time sink I should automate and yet not
trivially quick. I did a quick test and found it takes <p class="todo">insert time</p>  seconds to open a tab, enter the URL,
navigate the file opener, then wait for the result. I do this several times a day typically, so its time
to bite the bullet and automate.

<br>

<h1>The goal</h1>

I wanted to be able to Right-Click and select "Scan With VirusTotal". So this meant changing the Windows Registry to
point at some code. I've never been very comfortable working with the Registry. It feels like a dumping ground for 30
years of bad Windows design and poorly documented features. Fortunately, the changes I would need to make were simple to
<a href="https://www.howtogeek.com/107965/how-to-add-any-application-shortcut-to-windows-explorers-context-menu/">find</a>

<br>
Ok, so onto the actual code. I initially tried registering for VirusTotal's API. I intended to make a Python or Java
program.
I was going to go with whatever they had a reference client for. I got my API key and promptly started flailing. I have
no idea why it wouldn't work. I may revisit it in the future. But I put in a fruitless 1.5 hours of failing with their examples,
putting a proxy in between to observe the traffic on the wire, and several emails back and forth with a nice Customer Support rep
(no sarcasm, she was nice, unfortunately, my exact call worked on her end).

<br>
I moved on. I noticed in most cases (95+%) VirusTotal has already seen the file I'm scanning. So there's no need to
upload it, just to generate the SHA-256 hash, which is passed as a URL parameter. So I decided the web is the ultimate API, lets go
a simple HTTP GET in the browser.

<h1>A foray into PowerShell</h1>

<br>
I also decided to change tools. I really didn't want a dependency on something like the Java or Python Runtimes.
Nor did I want to have to compile. So that left native scripting and on Windows batch files seem to be being pushed out
in favor of PowerShell. So this was a good opportunity to play with that.

<br>
The PowerShell ISE isn't bad and I was able to use the interactive shell to work through the individual commands. The
auto completion and command reference made it pretty easy to create a script that SHOULD have worked. Instead, on script
execution I got this:
<p class="todo">scripting error image</p>
<br>
Windows ships with a Script Execution Policy, which seemed straightforward (and in retrospect it was). Due to safety
concerns by default the setting is "Restricted". No scripts (even ones written locally) will run. Ok, we want
"RemoteSigning". That enables local scripts to run and scripts downloaded from the internet to run if they are signed
by a valid publisher OR if we use the Unblock-File commandlet. Great.
<br>
What followed was another hour of frustration. The changes I made as an admin were not being reflected into the
non-admin PowerShell session...
<br>
So dear reader, if you want to descend into madness, read on. To cheerfully jump over the pit of madness to the
solution, <a href="#Solution">skip below</a>.
<ol>
    <li>I closed the non-admin window and reopened. Maybe it was holding onto old environment variable values? Nope.</li>
    <li>I re-read the docs on Execution Policy. Seemed like everything was ok. The script ran
        when I was admin, but I don't want to run as admin for safety reasons. Maybe I need to Unblock the file???
        No relief there.
    </li>
    <li>Let's try setting "Bypass" from the admin. Nope non-admin still can't run it.</li>
    <li>The non-admin doesn't even seem to see the admin changes I started thinking about how Windows permissions work and
        wondering which policy would apply. For some reason the LocalMachine policy I was setting
        wasn't being picked up. Hell, it wasn't even being seen. Maybe the non-admin user's CurrentUser setting was
        overriding it? But how to change that value? You have to be Admin to change any of the policies. So I started looking
        at Group Policies. Ugh.
    </li>
    <li>Walked around the block</li>
    <li>I started digging into vaguely conspiratorial StackOverflow threads about PowerShell bugs and incorrect
        documentation
    </li>
    <li>Other things I've forgotten</li>
</ol>

<h2 id="Solution">The last place you look</h2>
And then I noticed a subtle difference. Can you spot it?

<br>
PowerShell x86 vs PowerShell. Were they considered different applications (with different policies) by the OS? Yes...
Now everything works.

<br>
I had some apprehension about posting this. If I was a potential employer, I might look at this post and think "Pass on
this guy".
However, with nearly 10 years doing this and having the benefit of seeing and helping my peers I understand this is not
an isolated incident.
Everyone who works in a technical capacity goes through this regularly and most people don't talk about it. (Let's be real, spending nearly 4 hours in the
creation of a simple script is
not a recipe for self-esteem). But this silence contributes to a general imposter syndrome within the
industry.
Everyone just sees other people's finished product, not the boneheaded moments. So this is my first entry in a series I'm calling
"Doofus Developer."

<br>
So what did I get for my 4 hours in? If we assume I spend a minute or 2 a day on scanning files in 3-6 months I'm
breaking even. If other people gets some use out of it in a Kum ba yah, good karma type of way it feels like a faster break even.
Plus it's a source of writing material :). </p>

</body>
</html>